//varying vec2 UV;
//varying vec3 viewRay;



uniform sampler2D sysTextureSampler0;
uniform sampler2D sysDepthSampler;
//uniform samplerCube sysTextureSamplerCube0;
uniform samplerCube sys3DShadowSampler;

//uniform mat4 cameraToWorldMatrix;
//uniform mat4 worldToLightMatrix;
//uniform mat4 lightModelViewProjectionMatrix;
uniform mat4 sysCameraToLightProjectionMatrix;

uniform float sysZNear;
uniform float sysZFar;
uniform float sysLightZNear;
uniform float sysLightZFar;

uniform float sysRenderTargetWidth;
uniform float sysRenderTargetHeight;

uniform float useShadows;

#define sysLightType int(gl_LightSource[1].spotCutoff)
#define sysLightRadius gl_LightSource[0].diffuse.a

//varying mat4 inverse_projection_matrix;
//varying mat4 inverse_modelview_matrix;
varying float z;

float linearDepth(float depthSample)
{
    float zlin;
    depthSample=2.0*depthSample-1.0;
    zlin=2.0*sysZNear*sysZFar/(sysZFar+sysZNear-depthSample*(sysZFar-sysZNear));
    return zlin;
}

void intersect_sphere(vec3 center, vec3 view_point, vec3 view_direction, out float depth0, out float depth1, float radius)
{

    vec3 Q = center - view_point;
    float c = length(Q);
    float v = dot(Q,view_direction);
    float d = (radius*radius) - ( c*c - v*v );

    if(d<0.0f)
    {
        depth0 = depth1 = 0.0;
    }
    else
    {
        d = sqrt(d);
        depth0 = v-d;
        depth1 = v+d;
    }
}


float shade_point(vec3 light_pos, float light_radius, vec3 position)
{
	vec3 lvec=light_pos-position;
	float lvec_len=dot(lvec, lvec);
	//return clamp(((light_radius*light_radius)-lvec_len)/lvec_len, 0.0f, 1.0f);
	return (((light_radius*light_radius)-lvec_len)/(lvec_len))*0.08;
}

vec4 get_view_pos(vec4 h_pos, mat4 inverse_projection_matrix)
{
	vec4 temp = inverse_projection_matrix * h_pos;
	temp /= temp.w;
	return temp;
}



void main()
{

    vec3 view_vec;
    vec3 eye_view_vec;
    vec3 camera_pos;
    vec3 light_pos;
    
    
    vec4 vcolor=gl_LightSource[0].diffuse;
	vec2 uv = vec2(gl_FragCoord.x / sysRenderTargetWidth, gl_FragCoord.y / sysRenderTargetHeight);
	vec3 view_ray;
	vec4 t;
	vec3 cur_pos;
	vec3 eye_cur_pos;
	float depth0;
	float depth1;
	float start_depth;
	float end_depth;
	float step_len_world;
	//float scattering = gl_LightSource[2].linearAttenuation;
	float scattering = 0.15;
	float accum=0.0;
	float shadow;
	float dFactor;
	float depth=linearDepth(texture2D(sysDepthSampler, uv).x);	/* 0...1 to 0...far */
	float noise=texture2D(sysTextureSampler0, vec2(uv.x, uv.y)*vec2(192.0, 108.0)).x * 10.0;
	
	//vec3 noise = texture2D(sysTextureSampler0, vec2(uv.x, uv.y)*vec2(192.0, 108.0)).x * 50.0;
	//noise *= vec3(1.0 / sysRenderTargetWidth, 1.0 / sysRenderTargetHeight, 1.0);
	//float noise = texture2D(sysTextureSampler0, vec2(uv.x, uv.y) * 1000.0);
	//float noise = 0.0;
	
	float fz;
	int l;
	//int step_count = int(gl_LightSource[2].spotCutoff);
	int step_count = 8;
	
	
	vec4 j = gl_ProjectionMatrixInverse * vec4(uv.x * 2.0 - 1.0, uv.y * 2.0 - 1.0, -depth, 1.0);
	j.xyz / j.w;
	view_vec = normalize(j.xyz);
	//view_ray = j.xyz;
	
	//eye_view_vec = normalize(view_ray);
	
	
	//view_vec = vec3(gl_ModelViewMatrixInverse * vec4(view_ray, 0.0));
	//light_pos = vec3(gl_ModelViewMatrixInverse * vec4(gl_LightSource[0].position.xyz, 1.0));
	
	//camera_pos[0] = gl_ModelViewMatrixInverse[3][0];	
	//camera_pos[1] = gl_ModelViewMatrixInverse[3][1];
	//camera_pos[2] = gl_ModelViewMatrixInverse[3][2];
	
	//view_vec = normalize(light_pos - camera_pos);
	//eye_view_vec = vec3(0.0, 0.0, -1.0);
	
	//float pz = length(view_vec);
	//view_vec /= pz;
	
	
	intersect_sphere(gl_LightSource[0].position.xyz, vec3(0.0, 0.0, 0.0), view_vec, depth0, depth1, gl_LightSource[0].diffuse.a);
	
    start_depth = max(0.0, depth0);
  	start_depth=min(depth / (-view_vec.z), start_depth);
    end_depth = max(0.0, depth1);
	end_depth=min(depth / (-view_vec.z), end_depth);

	//eye_cur_pos = eye_view_vec * start_depth;
	cur_pos = view_vec * start_depth;
	step_len_world = (end_depth - start_depth) / float(step_count);
	
	//cur_pos -= step_len_world*view_vec;
		
	cur_pos += view_vec*step_len_world*(2.0*noise-1.0);
	//cur_pos += view_vec * (step_len_world + noise);
	shadow=1.0;
	
	for(l=0; l<step_count; l++)
	{
		cur_pos += step_len_world * view_vec;
		//eye_cur_pos += step_len_world * eye_view_vec;
		
		//if(useShadows > 0.0)
		{
			t = sysCameraToLightProjectionMatrix * vec4(cur_pos, 1.0);
			shadow = 0.0;
			
			t.y = -t.y;
			
			dFactor=textureCube(sys3DShadowSampler, t.xyz).r;
			
			vec3 av = abs(t.xyz);
			fz = max(av.x, max(av.y, av.z));
			fz = (sysLightZFar + sysLightZNear) / (sysLightZFar - sysLightZNear) - (2.0 * sysLightZFar * sysLightZNear)  / ((sysLightZFar - sysLightZNear)*fz);
			fz = fz * 0.5 + 0.5;

			
			if(fz<dFactor) shadow = 1.0;
		}
		

		accum+=shade_point(gl_LightSource[0].position.xyz, gl_LightSource[0].diffuse.a, cur_pos) * scattering * step_len_world * shadow;
	}
	
	gl_FragColor=vcolor*accum;
}




